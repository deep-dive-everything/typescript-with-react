# 1. 타입 확장하기

## 1.1 타입 확장의 장점

- 코드 중복을 줄일 수 있음. 중복되는 타입을 반복적으로 선언하기 보다 기존에 작성한 타입을 바탕으로 확장하며 불필요한 코드 중복을 줄일 수 있음.
- 명시적인 코드 작성
- 확장성 : 요구사황이 늘어나는것을 타입확장으로 반영 가능, 수정시 기존 타입 하나만 수정하면 확장된 타입에 일괄 적용됨.

```jsx
interface BaseCartItem extends BaseMenuItem {
	quantity: number;
};

type BaseCartItem = {
	quantity: number;
} & BaseMenuItem;
```

## 1.2 유니온 타입

```jsx
type MyUnion = A | B;
```

- 2개 이상의 타입을 조합하여 사용하는 방법
- 유니온 타입으로 선언된 값은 유니온 타입에 포함된 모든 타입이 공통으로 갖고 있는 속성에만 접근할 수 있음.
    - 합집합 vs 교집합
        - **값의 집합** 차원에서 유니온 타입은 여러 타입이 가질 수 있는 값들의 **합집합**입니다. 즉, 두 타입이 가질 수 있는 모든 값을 포함합니다.
        - **속성 접근** 차원에서 유니온 타입은 공통된 속성만 안전하게 접근할 수 있는데, 이는 두 타입 간의 **공통 속성(교집합)**만 사용할 수 있다는 의미입니다.
        
        결국, 유니온 타입은 **값의 차원에서는 합집합**이고, **속성 접근의 차원에서는 교집합**처럼 동작하는 이유는 타입스크립트의 타입 안전성 때문입니다.
        

## 1.3 교차 타입

```jsx
type MyIntersection = A & B;
```

- 두개의 타입을 합쳐 모든 속성을 가진 단일 타입이 됨.
- 타입이 호환되지 않는 경우

```jsx
type IdType = string | number;
type Numeric = number | boolean;

type Universal = IdType & Numeric;
```

- 이때 Universal 의 타입은 IdType과 Numeric의 교차 타입이므로 두 타입을 모두 만족하는 경우에만 유지됨. 따라서 number임

## 1.4 extends와 교차타입

- extends와 교차타입의 차이점
- type키워드는 새로 추가되는 속성을 미리 알수 없기 때문에 선언시 에러가 발생하지 않음. 이때 같은 속성에 대해 서로 호환되지 않는 타입이 선언되면 never타입이 됨.

```jsx
interface DeliveryTip {
	tip: number;
}

interface Filter extends DeliveryTip {
	tip: string;
	//에러
}

type DeliveryTip {
	tip: number;
}

type Filter = DeliveryTip & {
	tip: string;
	//이때 tip의 속성은 never
}
```

# 2. 타입좁히기 - 타입 가드

- 변수 또는 표현식의 타입 범위를 더 작은 범위로 좁혀나가는 과정.
- 정확하고 명시적인 타입 추론 가능, 복잡한 타입을 작은 범위로 축소하여 안정성 향상

## 2.1 타입 가드에 따라 분기 처리하기

- 타입 가드 :  런타임에 조건문을 사용하여 타입을 검사하고 타입 범위를 좁혀주는 기능.
- 스코프 : 변수와 함수 등의 식별자가 유효한 범위. 변수와 함수를 선언하거나 사용할 수 있는 영역.
- 컴파일해도 타입 정보가 사라지지 않는 방법을 사용해야함 : 컴파일시 타입 정보가 모두 제거되어 런타임에 존재하지 않기 때문.
- 자바스크립트 연산자를 활요한 타입 가드 : typeof, instanceof, in
- 사용자 정의 타입 가드 : 사용자가 직접 어떤 타입으로 값을 좁힐지 직접 지정하는 방식

## 2.2 원시 타입을 추론할 때 : typeof 연산자 활용하기

- typeof 연산자로 원시 타입을 추론할 수 있음.
- 자바스크립트 타입 시스템만 대응할 수 있음. 따라서 원시 타입을 좁히는 용도로만 사용할것을 권장.
- string, number, boolean, undefined, object, function, bigint, symbol

## 2.3 인스턴스화된 객체 타입을 판별할 때 : instanceof 연산자 활용하기

- 인스턴스화된 객체 타입을 판별하는 타입 가드.

```jsx
A instanceof B
//A : 타입을 검사할 대상 변수
//B : 특정 객체의 생성자
```

- A의 프로토타입 체인에 생성자 B가 존재하는지를 검사해 존재하면 ture, 그렇지않으면 false를 반환함.

## 2.4 객체의 속성이 있는지 없는지에 따른 구분 : in 연산자 활용

- 객체에 속성이 있는지 확인한 뒤 t/f 반환.

```jsx
A in B
//A 속성이 B에 존재하는지 여부
```

- 여러 객체를 유니온 타입으로 가지고 있는 경우 in 연산자로 속성 유무에 따라 조건 분기 가능
